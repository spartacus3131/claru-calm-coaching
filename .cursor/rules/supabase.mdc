---
description: Supabase patterns for Claru (PostgreSQL, Auth, RLS)
globs: ["**/*.ts", "**/*.tsx", "**/*.sql"]
alwaysApply: true
---

# Supabase Rules

## Client Setup

ALWAYS use the correct Supabase client for the context:

```typescript
// SERVER: API routes, Server Components, Server Actions
import { createServerClient } from '@supabase/ssr';
import { cookies } from 'next/headers';

export async function createServerSupabase() {
  const cookieStore = await cookies();
  return createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        getAll() {
          return cookieStore.getAll();
        },
        setAll(cookiesToSet) {
          cookiesToSet.forEach(({ name, value, options }) => {
            cookieStore.set(name, value, options);
          });
        },
      },
    }
  );
}

// CLIENT: React components with "use client"
import { createBrowserClient } from '@supabase/ssr';

export function createBrowserSupabase() {
  return createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  );
}
```

## Authentication

ALWAYS get user from server-side, never trust client:

```typescript
// CORRECT: Server-side auth check
export async function POST(request: Request) {
  const supabase = await createServerSupabase();
  const { data: { user }, error } = await supabase.auth.getUser();
  
  if (!user) {
    return Response.json({ error: 'Unauthorized' }, { status: 401 });
  }
  
  // user.id is the authenticated user's UUID
  // Use this for all queries
}

// WRONG: Trusting client-provided userId
export async function POST(request: Request) {
  const { userId } = await request.json(); // NEVER trust this
}
```

## Row-Level Security (RLS)

EVERY table MUST have RLS enabled. No exceptions.

```sql
-- ALWAYS do this for every table
ALTER TABLE table_name ENABLE ROW LEVEL SECURITY;

-- Standard pattern: users can only access their own data
CREATE POLICY "Users can access own data" ON table_name
  FOR ALL
  USING (auth.uid() = user_id);
```

For tables without direct user_id (like conversation_turns):

```sql
-- Join to parent table for ownership check
CREATE POLICY "Users can access own turns" ON conversation_turns
  FOR ALL
  USING (
    EXISTS (
      SELECT 1 FROM coaching_sessions
      WHERE id = conversation_turns.session_id
      AND user_id = auth.uid()
    )
  );
```

## Query Patterns

ALWAYS handle errors from Supabase queries:

```typescript
// CORRECT: Check for errors
const { data, error } = await supabase
  .from('daily_notes')
  .select('*')
  .eq('user_id', user.id)
  .single();

if (error) {
  console.error('Database error:', error);
  throw new Error('Failed to fetch note');
}

// WRONG: Ignoring errors
const { data } = await supabase.from('daily_notes').select('*');
// What if this fails silently?
```

ALWAYS filter by user_id even with RLS (defense in depth):

```typescript
// CORRECT: Explicit user_id filter
const { data } = await supabase
  .from('daily_notes')
  .select('*')
  .eq('user_id', user.id) // Defense in depth
  .eq('date', today);

// WRONG: Relying only on RLS
const { data } = await supabase
  .from('daily_notes')
  .select('*')
  .eq('date', today);
```

## Insert Patterns

USE upsert for "create or update" patterns:

```typescript
// CORRECT: Upsert for daily notes (one per user per day)
const { error } = await supabase
  .from('daily_notes')
  .upsert(
    {
      user_id: user.id,
      date: today,
      raw_dump: content,
    },
    {
      onConflict: 'user_id,date',
    }
  );
```

## Type Safety

ALWAYS generate and use Supabase types:

```bash
# Generate types from your database
npx supabase gen types typescript --project-id YOUR_PROJECT_ID > src/lib/database.types.ts
```

```typescript
// Use generated types
import { Database } from '@/lib/database.types';

type DailyNote = Database['public']['Tables']['daily_notes']['Row'];
type InsertNote = Database['public']['Tables']['daily_notes']['Insert'];
```

## Connection Pooling

For high-volume queries, use the connection pooler:

```typescript
// For transaction-heavy operations
const supabase = createClient(
  process.env.SUPABASE_URL!,
  process.env.SUPABASE_ANON_KEY!,
  {
    db: {
      schema: 'public',
    },
    auth: {
      persistSession: false,
    },
  }
);
```

## FORBIDDEN Patterns

NEVER do these:

```typescript
// FORBIDDEN: Service role key in client code
const supabase = createClient(url, process.env.SUPABASE_SERVICE_ROLE_KEY);

// FORBIDDEN: Exposing service role key
// NEXT_PUBLIC_SUPABASE_SERVICE_ROLE_KEY ‚Üê NEVER DO THIS

// FORBIDDEN: Tables without RLS
CREATE TABLE notes (...); // Missing ALTER TABLE ... ENABLE ROW LEVEL SECURITY

// FORBIDDEN: Trusting client-provided IDs
const { userId } = await request.json();
await supabase.from('notes').select().eq('user_id', userId);

// FORBIDDEN: Ignoring query errors
const { data } = await supabase.from('notes').select();
return data; // What if error occurred?
```
